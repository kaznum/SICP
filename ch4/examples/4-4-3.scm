(and (job ?x (computer programmer))
     (supervisor ?x ?y))

(and (supervisor ?x ?y)
     (job ?x (computer programmer)))
;; If supervisors is less than programmer,
;; the first is better than the second because
;; the number of intermediate frames is less.

;; The aim of logical programming is to provide the programmers
;; the technique of decomposing 'what' is to be computed and 'how' that should be computed.

;; 'Rule' holds the 'way' to compute the problem procedurally in body, at the same time,
;; this can be regarded as the 'statement(what)' of methematical logic (inference).

;;;; Inifinite loops

(assert! (married Minnie Mickey))

(married Mickey ?who) ;; no match

(assert! (rule (married ?x ?y) (married ?y ?x)))

(married Mickey ?who) ;; Infinite loop

;;;; Problems with not

(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))

(and (not (job ?x (computer programmer)))
     (supervisor ?x ?y))
;; Those above dont result in same result.

;; At the first one,
;; the first incomming frames is

;; (<empty>)

;; and the first part of the expression matches to (supervisor ?x ?y)

;; (supervisor (Hacker Alyssa P) (Bitdiddle Ben))
;; (supervisor (Fect Cy D) (Bitdiddle Ben))
;; (supervisor (Tweakit Lem E) (Bitdiddle Ben))
;; (supervisor (Reasoner Louis) (Hacker Alyssa P))
;; (supervisor (Bitdiddle Ben) (Warbucks Oliver))
;; (supervisor (Scrooge Eben) (Warbucks Oliver))
;; (supervisor (Cratchet Robert) (Scrooge Eben))
;; (supervisor (Aull DeWitt) (Warbucks Oliver))

;; then the stream of frames generated by the first part is as follows

;; (<empty>) -> (?x (Hacker Alyssa P))
;; (<empty>) -> (?x (Fect Cy D))
;; (<empty>) -> (?x (Tweakit Lem E))
;; (<empty>) -> (?x (Reasoner Louis))
;; (<empty>) -> (?x (Bitdiddle Ben))
;; (<empty>) -> (?x (Scrooge Eben))
;; (<empty>) -> (?x (Cratchet Robert))
;; (<empty>) -> (?x (Aull DeWitt))

;; which are passed to the second part of expression (not (job ?x (computer programmer)))

;; (not (job (Hacker Alyssa P) (computer programmer))) ;; matched -> false: Hacker is (computer programmer) in DB
;; (not (job (Fect Cy D) (computer programmer))) ;; matched -> false: Fect is (computer programmer) in DB
;; (not (job (Tweakit Lem E) (computer programmer))) ;; unmatched -> true: Tweakit is (computer technician)
;; (not (job (Reasoner Louis) (computer programmer))) ;; unmatched -> true: Reasoner is (computer programmer trainee) in DB
;; (not (job (Bitdiddle Ben) (computer programmer))) ;; unmatched -> true: Bitdiddle is (computer wizard) in DB
;; (not (job (Scrooge Eben) (computer programmer))) ;; unmatched -> true: Scrooge is (accounting chief accountant)
;; (not (job (Cratchet Robert) (computer programmer))) ;; unmatched -> true: Cratchet Robert is (accounting scriverner)
;; (not (job (Aull DeWitt) (computer programmer))) ;; unmatched -> true: Aull is (administration secretary)

;; then all expressions generate the stream of the frame as follows,

;; (?x (Tweakit Lem E))
;; (?x (Reasoner Louis))
;; (?x (Bitdiddle Ben))
;; (?x (Scrooge Eben))
;; (?x (Cratchet Robert))
;; (?x (Aull DeWitt))

;; 'not' filters the "incomming frames (not database)" which don't match (job ?x (computer ...))
;; At the second one, the incommint frames initially are empty then
;; (not (job ?x (computer programmer)) results in empty so the entire expression
;; of the second results in empty frames.
;; This occurs because ?x is unbound.

;; For the second example,
;; The initial frame is

;; (<empty>)

;; In the first part of expression (job ?x (computer programmer)) matches to the entries of database

;; (job (Hacker Alyssa P) (computer programmer))
;; (job (Fect Cy D) (computer programmer))

;; Anytime there are the matched entries, then 'not' filter out the incomming empty frame
;; then results in removing the initial empty frame and generates the empty stream of frames.
;; The second part is not evaluated because there is no frames to be input(even the initial empty frame),
;;  then the entire expression results in the empty stream of frames.
